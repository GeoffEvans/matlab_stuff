function [ a, b, c, ticksPerRamp ] = driver_wrapper( scanVar,systemVar,xyzNormalised )

[...
    imagingMode,...    
    aodMode,...
    xyNumOfElems,...
    acceptanceAngle,... % mrad
    dwellTime,...
    zoomFactor,...
    optimalFrequency,...
    imageCentreNormalised,...
    scanDisplacementNormalised,...
    systemClockFreq,...
    pairDeflectionRatio,...
    dataTimeInterval,...
    aodAperture,...
    V,...
    opWavelenVac...
] = ExtractVariablesFromStructs( scanVar,systemVar,xyzNormalised );

[baseFreq, linearChirp, quadChirp, rampTime, isMiniscan] = microscope_driver(...
    imagingMode,...    
    aodMode,...
    xyNumOfElems,...
    acceptanceAngle,... % mrad
    dwellTime,...
    zoomFactor,...
    optimalFrequency,...
    imageCentreNormalised,...
    scanDisplacementNormalised,...
    pairDeflectionRatio,...
    aodAperture,...
    V,...
    opWavelenVac);

function [a, b, c, ticksPerRamp] = ComputeReturnsForLabview(baseFreq, linearChirp, quadChirp, rampTime, isMiniscan)

    a = SwapScaleAndRound(baseFreq', 2^32 / systemClockFreq);
    b = SwapScaleAndRound(linearChirp', 2^32 / systemClockFreq^2 * 2 / 2^3); % scale B down here and expand later
    c = SwapScaleAndRound(quadChirp', 2^32 / systemClockFreq^3 * ((3*2^13))); % ((...)) is scaling due to original implementation on FPGAs
    d = SwapScaleAndRound();
    
    aodFillTime = dataTimeInterval * ceil(aodAperture / V / dataTimeInterval);
    scanTime = aodFillTime + rampTime; % the scan time for each point

    if isMiniscan
        ticksPerRamp =  SwapScaleAndRound( repmat(scanTime(:), 1, 4), systemClockFreq);
    else
        ticksPerRamp =  SwapScaleAndRound( repmat(scanTime, 200, 4), systemClockFreq);
    end

    function y = SwapScaleAndRound(x,scaleFactor)
        y = round( x * scaleFactor );
        y(:,[3 2]) = y(:,[2 3]);
    end
end

[a, b, c, ticksPerRamp] = ComputeReturnsForLabview(baseFreq, linearChirp, quadChirp, rampTime, isMiniscan);

end

function [...
    imagingMode,...    
    aodDiffractionMode,...
    xyNumOfElems,...
    acceptanceAngle,... % mrad
    dwellTime,...
    zoomFactor,...
    optimalFrequency,...
    imageCentreNormalised,...
    scanDispNormalised,...
    systemClockFreq,...
    pairDeflectionRatio,...
    dataTimeInterval,...
    aodAperture,...
    V,...
    wavelength] ...
        = ExtractVariablesFromStructs(scanVar,systemVar,xyzNorm)

if scanVar.aolMode == 1    
    imagingMode = 'miniscan';
elseif scanVar.aolMode == 2   
    imagingMode = 'structural';
else
    error('something went wrong...')
end
aodDiffractionMode = systemVar.diffractionMode;
xyNumOfElems = scanVar.numberOfVoxels;
acceptanceAngle = scanVar.acceptanceAngle * 1e3; % mrad
dwellTime = scanVar.dwellTime;
zoomFactor = scanVar.zoomFactor;
optimalFrequency = scanVar.centreFrequency;
imageCentreNormalised = xyzNorm.imageCentreNormalised'; % transpose
scanDispNormalised = xyzNorm.imageStopNormalised' - xyzNorm.imageStartNormalised'; % transpose
systemClockFreq = systemVar.controlClockFreq;
pairDeflectionRatio = systemVar.pairDeflectionRatio;
V = 612.8;
dataTimeInterval = systemVar.dataTimeInterval; 
aodAperture = systemVar.crystalLength;
wavelength = scanVar.opticalWaveLength;

% Currently hardcoded but need to be added in future:
    %'opticalWaveLength'
    %'crystalLength'
    %'acousticVelocity'
    %'seperationOfAod1Aod2'
    %'seperationOfAod2Aod3'
    %'seperationOfAod3Aod4'
    %'thicknessOfAod1'
    %'thicknessOfAod2'
    %'thicknessOfAod3'
    %'thicknessOfAod4'
end